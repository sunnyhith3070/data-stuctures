class node:
    def __init__(self,value):
        self.data=value
        self.left=None
        self.right=None
class binarytree:
    def __init__(self):
        self.root=None
    #tree traversal1
    def traversalspiral(self):
        h1=self.height(self.root)
        k=-1
        for i in range(1,h1+1):
            self.ts(self.root,i,k)
            k=-k
    def ts(self,p,level,k):
        if p is None:
            return
        elif level==1:
            print(p.data,end=" ")
        elif level>1:
            if k==1:
                self.ts(p.left,level-1,k)
                self.ts(p.right,level-1,k)
            elif k==-1:
                self.ts(p.right,level-1,k)
                self.ts(p.left,level-1,k)
    #tree traversal2
    def traversal(self):
        self.util(self.root)
    def util(self,p):
        q=[]
        q.append(p)
        while len(q):
            y=q[0]
            if y.left != None:
                q.append(y.left)
            if y.right != None:
                q.append(y.right)
            x=q.pop(0)
            print(x.data,end=" ")
        
    
    #height           
    def h(self):
        t=self.height(self.root)
        print(t)
    def height(self,p):
        if p is None:
            return 0
        else:
            return 1+max(self.height(p.left),self.height(p.right))
    #diameter
    def diameter(self):
        return self.diameterutil(self.root)
    def diameterutil(self,p):
        if p is None:
            return 0
        ld=self.diameterutil(p.left)
        rd=self.diameterutil(p.right)
        lh=self.height(p.left)
        rh=self.height(p.right)
        return max(1+lh+rh,max(ld,rd))
    #maxsumpath between any two nodes
    def maxpathsum(self):
        x=self.util(self.root)
        print(x)
        
    def summ(self,p):
        if p is None:
            return 0
        return p.data+max(self.summ(p.left),self.summ(p.right))
    def util(self,p):
        if p is None:
            return 0
        lu=self.util(p.left)
        ru=self.util(p.right)
        ls=self.summ(p.left)
        rs=self.summ(p.right)
        return max(ls+rs+p.data,max(lu,ru))
    #balancedtree
    def balancedtree(self):
        return self.btutil(self.root)
    def btutil(self,p):
        if  p is None:
            return True
        hl=self.height(p.left)
        hr=self.height(p.right)
        if abs(hl-hr)<=1 and self.btutil(p.left) and self.btutil(p.right):
            return True
        else:
            return False
        
            
    def createtree(self):
        self.root=node(1)
        self.root.left=node(2)
        self.root.right=node(3)
        self.root.left.left=node(7)
        self.root.left.right=node(6)
        self.root.right.left=node(5)
        self.root.right.right=node(4)
 #without using class binary tree checking identical or not
 def identical(a,b):
    
    if a is None and b is None:
        return True
    elif a.data==b.data and identical(a.left,b.left) and identical(a.right,b.right):
        return True
    return False
        
l=binarytree()
l.createtree()
l.traversalspiral()
